#!/usr/bin/env python3
# File: SQLiteToMySQL_DataDump.py
# Path: Scripts/DataBase/SQLiteToMySQL_DataDump.py
# Standard: AIDEV-PascalCase-2.1
# Created: 2025-06-15
# Last Modified: 2025-07-17  09:59AM

"""
SQLiteToMySQL_SchemaAndDataDump_AutoDBName.py
Standard: AIDEV-PascalCase-2.1

Purpose:
Converts an arbitrary SQLite database to a MySQL-compatible SQL script.
The database name is automatically derived from the output SQL filename.
Does not touch MySQL directly.

Author: Himalaya Project
"""

import sqlite3
import argparse
import os

TYPE_MAP = {
    "INTEGER": "INT",
    "TEXT": "VARCHAR(255)",
    "REAL": "FLOAT",
    "BLOB": "LONGBLOB",
    "NUMERIC": "FLOAT"
}

def GenerateSQLDump(sqlite_path, output_path, db_name):
    sqlite_conn = sqlite3.connect(sqlite_path)
    sqlite_cur = sqlite_conn.cursor()

    with open(output_path, "w") as f:
        f.write(f"-- SQL Dump Generated by Himalaya SQLite to MySQL Tool\n\n")
        f.write(f"CREATE DATABASE IF NOT EXISTS `{db_name}`;\n")
        f.write(f"USE `{db_name}`;\n\n")
        f.write("SET FOREIGN_KEY_CHECKS = 0;\n\n")

        sqlite_cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%';")
        tables = [row[0] for row in sqlite_cur.fetchall()]

        for table in tables:
            f.write(f"-- Table: {table}\n")
            sqlite_cur.execute(f"PRAGMA table_info({table});")
            columns_info = sqlite_cur.fetchall()

            column_defs = []
            primary_keys = []
            for col in columns_info:
                col_name = col[1]
                col_type = col[2].upper()
                col_type_mysql = TYPE_MAP.get(col_type, "VARCHAR(255)")
                column_defs.append(f"`{col_name}` {col_type_mysql}")
                if col[5]:
                    primary_keys.append(f"`{col_name}`")

            create_stmt = f"CREATE TABLE `{table}` ({', '.join(column_defs)}"
            if primary_keys:
                create_stmt += f", PRIMARY KEY ({', '.join(primary_keys)})"
            create_stmt += ");\n\n"
            f.write(create_stmt)

            columns = [col[1] for col in columns_info]
            col_list = ", ".join(f"`{c}`" for c in columns)

            sqlite_cur.execute(f"SELECT {col_list} FROM `{table}`;")
            rows = sqlite_cur.fetchall()

            for row in rows:
                values = []
                for val in row:
                    if val is None:
                        values.append("NULL")
                    elif isinstance(val, (int, float)):
                        values.append(str(val))
                    else:
                        escaped = str(val).replace("'", "''")
                        values.append(f"'{escaped}'")
                insert_stmt = f"INSERT INTO `{table}` ({col_list}) VALUES ({', '.join(values)});\n"
                f.write(insert_stmt)

            f.write("\n")

        f.write("SET FOREIGN_KEY_CHECKS = 1;\n")
    sqlite_conn.close()
    print(f"SQL dump written to: {output_path}")
    print(f"Database name used in script: {db_name}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Convert SQLite DB to MySQL SQL dump. DB name is derived from output filename.")
    parser.add_argument("sqlite_db", help="Path to the SQLite .db file")
    parser.add_argument("output_sql", help="Output .sql file path (e.g., 'MyDatabase.sql')")
    args = parser.parse_args()

    # Derive database name from the output filename
    db_name = os.path.splitext(os.path.basename(args.output_sql))[0]

    GenerateSQLDump(args.sqlite_db, args.output_sql, db_name)
